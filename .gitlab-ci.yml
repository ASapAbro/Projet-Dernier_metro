# Pipeline CI/CD pour l'API Dernier Metro Paris
# Version: 1.0.0

stages:
  - test
  - build
  - security
  - deploy

# Variables globales
variables:
  NODE_VERSION: "18"
  DOCKER_DRIVER: overlay2
  DOCKER_TLS_CERTDIR: "/certs"
  # Variables pour les tests
  NODE_ENV: "test"
  DB_HOST: "postgres"
  DB_PORT: "5432"
  DB_NAME: "dernier_metro_test"
  DB_USER: "metro_user"
  DB_PASSWORD: "metro_password"

# Cache pour acc√©l√©rer les builds
cache:
  key: "$CI_COMMIT_REF_SLUG"
  paths:
    - node_modules/
    - .npm/

# Services pour les tests (PostgreSQL)
services:
  - name: postgres:15-alpine
    alias: postgres
    variables:
      POSTGRES_DB: dernier_metro_test
      POSTGRES_USER: metro_user
      POSTGRES_PASSWORD: metro_password
      POSTGRES_HOST_AUTH_METHOD: trust

# √âtape 1: Tests unitaires et linting
test:unit:
  stage: test
  image: node:${NODE_VERSION}-alpine
  before_script:
    - apk add --no-cache curl postgresql-client
    - npm ci --cache .npm --prefer-offline
    # Attendre que PostgreSQL soit pr√™t
    - |
      for i in {1..30}; do
        if pg_isready -h postgres -p 5432 -U metro_user; then
          echo "PostgreSQL is ready!"
          break
        fi
        echo "Waiting for PostgreSQL... ($i/30)"
        sleep 2
      done
    # Initialiser la base de donn√©es de test
    - PGPASSWORD=metro_password psql -h postgres -U metro_user -d dernier_metro_test -f db/init/01_schema.sql
    - PGPASSWORD=metro_password psql -h postgres -U metro_user -d dernier_metro_test -f db/init/02_data.sql
  script:
    - echo "üß™ Ex√©cution des tests unitaires..."
    - npm test
    - echo "üìä G√©n√©ration du rapport de couverture..."
    - npm run test:coverage
  coverage: '/All files[^|]*\|[^|]*\s+([\d\.]+)/'
  artifacts:
    reports:
      coverage_report:
        coverage_format: cobertura
        path: coverage/cobertura-coverage.xml
    paths:
      - coverage/
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Validation de la syntaxe et linting
test:lint:
  stage: test
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "üîç V√©rification de la syntaxe JavaScript..."
    - npx eslint . --ext .js --ignore-path .gitignore || echo "ESLint non configur√©, v√©rification basique..."
    - echo "üìã Validation du package.json..."
    - npm audit --audit-level=moderate
  allow_failure: true
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Test de l'API avec curl
test:api:
  stage: test
  image: node:${NODE_VERSION}-alpine
  services:
    - name: postgres:15-alpine
      alias: postgres
      variables:
        POSTGRES_DB: dernier_metro_test
        POSTGRES_USER: metro_user
        POSTGRES_PASSWORD: metro_password
  before_script:
    - apk add --no-cache curl postgresql-client
    - npm ci --cache .npm --prefer-offline
    # Initialiser la base
    - |
      for i in {1..30}; do
        if pg_isready -h postgres -p 5432 -U metro_user; then break; fi
        sleep 2
      done
    - PGPASSWORD=metro_password psql -h postgres -U metro_user -d dernier_metro_test -f db/init/01_schema.sql
    - PGPASSWORD=metro_password psql -h postgres -U metro_user -d dernier_metro_test -f db/init/02_data.sql
  script:
    - echo "üöÄ D√©marrage de l'API en arri√®re-plan..."
    - PORT=3000 npm start &
    - APP_PID=$!
    - sleep 10
    - echo "üß™ Tests d'int√©gration API..."
    - chmod +x test_api.sh
    - ./test_api.sh
    - echo "üõë Arr√™t de l'API..."
    - kill $APP_PID || true
  artifacts:
    reports:
      junit: test-results.xml
    expire_in: 1 week
  rules:
    - if: $CI_PIPELINE_SOURCE == "push"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# ===== √âTAPE BUILD =====

# Construction de l'image Docker
build:docker:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
  variables:
    DOCKER_IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
    DOCKER_IMAGE_LATEST: "$CI_REGISTRY_IMAGE:latest"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üê≥ Construction de l'image Docker..."
    - docker build -t $DOCKER_IMAGE_TAG -t $DOCKER_IMAGE_LATEST .
    - echo "üì§ Push de l'image vers le registry..."
    - docker push $DOCKER_IMAGE_TAG
    - docker push $DOCKER_IMAGE_LATEST
    - echo "üìã Informations sur l'image:"
    - docker images $CI_REGISTRY_IMAGE
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Test de l'image Docker construite
build:test-docker:
  stage: build
  image: docker:24-dind
  services:
    - docker:24-dind
    - name: postgres:15-alpine
      alias: postgres
      variables:
        POSTGRES_DB: dernier_metro_test
        POSTGRES_USER: metro_user
        POSTGRES_PASSWORD: metro_password
  variables:
    DOCKER_IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
    - apk add --no-cache curl postgresql-client
  script:
    - echo "üß™ Test de l'image Docker construite..."
    - docker pull $DOCKER_IMAGE_TAG
    - echo "üöÄ D√©marrage du conteneur..."
    - |
      docker run -d --name api-test \
        -p 3000:3000 \
        -e NODE_ENV=production \
        -e DB_HOST=postgres \
        -e DB_PORT=5432 \
        -e DB_NAME=dernier_metro_test \
        -e DB_USER=metro_user \
        -e DB_PASSWORD=metro_password \
        --network host \
        $DOCKER_IMAGE_TAG
    - sleep 15
    - echo "üß™ Test de sant√© de l'API containeris√©e..."
    - curl -f http://localhost:3000/health || (docker logs api-test && exit 1)
    - echo "‚úÖ Image Docker valid√©e!"
  after_script:
    - docker stop api-test || true
    - docker rm api-test || true
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
  needs: ["build:docker"]

# ===== √âTAPE S√âCURIT√â =====

# Scan de s√©curit√© des d√©pendances Node.js
security:npm-audit:
  stage: security
  image: node:${NODE_VERSION}-alpine
  before_script:
    - npm ci --cache .npm --prefer-offline
  script:
    - echo "üîí Audit de s√©curit√© des d√©pendances npm..."
    - npm audit --audit-level=critical --json > npm-audit.json || true
    - echo "üìä R√©sultats de l'audit npm:"
    - cat npm-audit.json
    - echo "üîç V√©rification des vuln√©rabilit√©s critiques..."
    - CRITICAL_VULNS=$(cat npm-audit.json | grep -o '"critical":[0-9]*' | head -1 | cut -d':' -f2 || echo "0")
    - echo "Vuln√©rabilit√©s critiques trouv√©es: $CRITICAL_VULNS"
    - if [ "$CRITICAL_VULNS" -gt 0 ]; then echo "‚ùå Vuln√©rabilit√©s critiques d√©tect√©es!"; exit 1; fi
    - echo "‚úÖ Aucune vuln√©rabilit√© critique trouv√©e"
  artifacts:
    reports:
      dependency_scanning: npm-audit.json
    paths:
      - npm-audit.json
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"

# Scan de s√©curit√© de l'image Docker avec Trivy
security:container-scan:
  stage: security
  image: aquasec/trivy:latest
  variables:
    DOCKER_IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  before_script:
    - echo $CI_REGISTRY_PASSWORD | docker login -u $CI_REGISTRY_USER --password-stdin $CI_REGISTRY
  script:
    - echo "üîç Scan de s√©curit√© de l'image Docker avec Trivy..."
    - trivy image --format json --output trivy-report.json $DOCKER_IMAGE_TAG
    - echo "üìä R√©sum√© du scan:"
    - trivy image --format table $DOCKER_IMAGE_TAG
    - echo "üîç V√©rification des vuln√©rabilit√©s CRITICAL..."
    - CRITICAL_COUNT=$(cat trivy-report.json | grep -o '"Severity":"CRITICAL"' | wc -l || echo "0")
    - echo "Vuln√©rabilit√©s CRITICAL trouv√©es: $CRITICAL_COUNT"
    - if [ "$CRITICAL_COUNT" -gt 5 ]; then echo "‚ùå Trop de vuln√©rabilit√©s critiques!"; exit 1; fi
    - echo "‚úÖ Niveau de s√©curit√© acceptable"
  artifacts:
    reports:
      container_scanning: trivy-report.json
    paths:
      - trivy-report.json
    expire_in: 1 week
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
    - if: $CI_COMMIT_BRANCH == "develop"
  needs: ["build:docker"]

# ===== √âTAPE DEPLOY =====

# D√©ploiement en staging
deploy:staging:
  stage: deploy
  image: alpine:latest
  variables:
    DEPLOY_ENV: "staging"
    DOCKER_IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "üöÄ D√©ploiement en environnement staging..."
    - echo "Image √† d√©ployer: $DOCKER_IMAGE_TAG"
    - echo "Environment: $DEPLOY_ENV"
    - echo "üîó URL de staging: https://api-staging.dernier-metro.fr"
    - echo "‚úÖ D√©ploiement staging simul√© (impl√©mentation requise)"
  environment:
    name: staging
    url: https://api-staging.dernier-metro.fr
  rules:
    - if: $CI_COMMIT_BRANCH == "develop"
  needs: ["build:docker", "security:npm-audit"]

# D√©ploiement en production
deploy:production:
  stage: deploy
  image: alpine:latest
  variables:
    DEPLOY_ENV: "production"
    DOCKER_IMAGE_TAG: "$CI_REGISTRY_IMAGE:$CI_COMMIT_SHA"
  before_script:
    - apk add --no-cache curl
  script:
    - echo "üöÄ D√©ploiement en environnement production..."
    - echo "Image √† d√©ployer: $DOCKER_IMAGE_TAG"
    - echo "Environment: $DEPLOY_ENV"
    - echo "üîó URL de production: https://api.dernier-metro.fr"
    - echo "‚úÖ D√©ploiement production simul√© (impl√©mentation requise)"
  environment:
    name: production
    url: https://api.dernier-metro.fr
  rules:
    - if: $CI_COMMIT_BRANCH == "main"
  when: manual
  needs: ["build:docker", "security:npm-audit", "security:container-scan"]
